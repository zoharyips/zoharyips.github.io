---
layout: post
title: Java - 基础：IO 与 NIO
categories: Java
keywords: [java, io, nio]
date: 2021-03-05 18:34:00
image: /images/wallpaper/java_basic_io_and_nio.jpg
lang: java
search: true
qrcode: true
catalogue: true
prism: true
description: 所有程序都离不开输入输出，计算机就是为了响应输入，处理数据，输出结果的，因此 IO 对于一门编程语言而言是至关重要的。
---

在 Java 中，把不同类型的输入、输出抽象为流（Stream）。这个流被称为数据流，指输入输出的数据。

## IO 流

### IO 流分类

IO 流可以通过两个维度进行分类：

* 按照流的方向分为**输入流**和**输出流**。

    由程序操作内存向外部设备转移的数据流称为输出流。由外部设备向程序操作内存转移的数据流称为输入流。

* 按照流中的数据类型分为**字节流**和**字符流**。

    按字节读取的数据流称为字节流。按字符读取的数据流称为字符流。

    字符流并不总是按两个字节读取的。Java 采用 UTF-8 字符编码，为可变长字符编码，因此一个字符的长度可能是一、二甚至三个字节，有些文字符号甚至由两个字符组成。

    ~~~java
    public static void main(String[] args) {
        String a = "12345";
        System.out.println(a + "\nCHAR SIZE: " + a.toCharArray().length + ", BYTE SIZE: " + a.getBytes(StandardCharsets.UTF_8).length);
        String b = "ĀĀĀĀĀ";
        System.out.println(b + "\nCHAR SIZE: " + b.toCharArray().length + ", BYTE SIZE: " + b.getBytes(StandardCharsets.UTF_8).length);
        String c = "一二三四五";
        System.out.println(c + "\nCHAR SIZE: " + c.toCharArray().length + ", BYTE SIZE: " + c.getBytes(StandardCharsets.UTF_8).length);
        String d = "𡃁𡃁𡃁𡃁𡃁";
        System.out.println(d + "\nCHAR SIZE: " + d.toCharArray().length + ", BYTE SIZE: " + d.getBytes(StandardCharsets.UTF_8).length);
        String e = "👽👽👽👽👽‍";
        System.out.println(e + "\nCHAR SIZE: " + e.toCharArray().length + ", BYTE SIZE: " + e.getBytes(StandardCharsets.UTF_8).length);
    }
    ~~~

    结果：

    ~~~bash
    12345
    CHAR SIZE: 5, BYTE SIZE: 5
    ĀĀĀĀĀ
    CHAR SIZE: 5, BYTE SIZE: 10
    一二三四五
    CHAR SIZE: 5, BYTE SIZE: 15
    𡃁𡃁𡃁𡃁𡃁
    CHAR SIZE: 10, BYTE SIZE: 20
    👽👽👽👽👽‍
    CHAR SIZE: 11, BYTE SIZE: 23
    ~~~

所有字节输入流都继承 `InputStream` 类，所有字节输出流都继承 `OutputStream`，所有字符输出流都继承 `Reader` 类，所有字符输出流都继承 `Writer` 类。

### IO 流特点

Java 基础 IO 流对于输入输出以流进行抽象，向从管道中流入和流出的水流一样，只能从管道口取出数据，因此 Java 原始的的 IO 流只能固定地从流的头部逐个字节或逐个字符取出数据，而无法从中间截断获取出中间某部分的数据。

### IO 流类型

![Java IO 流类型](/images/posts/java/java_basic_io.png)

### 字节输入流

`InputStream` 是一个抽象类，规定了字节输入流的基础操作。

#### 基础操作

| 方法                       | 作用                                                                                                                                           |
|:---------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------|
| `read():int`               | 从字节流中读取 1 字节数据                                                                                                                      |
| `read(byte[]):int`         | 从字节流中读取多个字节数据到参数数组中                                                                                                         |
| `read(byte[], int, int)`   | 从字节流中读取多个字节数据到参数数组的指定范围中                                                                                               |
| `skip(long):long`          | 跳过字节流中指定数量的数据，放回跳过的数据量                                                                                                   |
| `available():int`          | 返回字节流中可读取的数据量                                                                                                                     |
| `mark(int readlimit):void` | 标记当前字节流读取的位置，在读取 `readlimit` 这么多字节数据之前保持标记生效，标记生效期间，可随时使用 `reset()` 方法将流读取位置重置到标记那里 |
| `reset():void`             | 将流读取位置重置到 `mark` 标志位处                                                                                                             |

由于 IO 流只能读取和操作流首部，因此这个标记和重置操作必须通过保存 `readlimit` 内的数据才能实现。

#### 实现类

已废弃的输入流不予以记录：

* `FileInputStream`
    文件输入流。用于处理文件。

* `FilterInputStream`
    用于为字节输入流添加额外功能，通过装饰模式实现。

    `FilterInputStream` 内部维护一个 `InputStream in` 数据成员，通过构造方法传入，通过对该成员进行各种操作实现对字节输入流功能的增强。

    | 实现类                | 作用                                         | 实现方式                                                                                 |
    |:----------------------|:---------------------------------------------|:-----------------------------------------------------------------------------------------|
    | `BufferInputStream`   | 缓存输入的字节                               | 内部维护一个 `byte[] buf` 字节数组作为缓存将输入流预先缓存到内存中，通常可以加快读取速度 |
    | `DataInputStream`     | 可以直接从流中读取整型、长整型等基本数据类型 | 封装一系列 API                                                                           |
    | `PushBackInputStream` | 可以将已读出的字节压回输入流中               | 内部维护一个 `byte[] buf` 实现，压回的数据并非真正压回流中，而是放入 `buf` 中            |

* `ObjectInputStream` 
    被称为反序列化流。用于从流中放序列化读取对象，类似于 `FilterInputStream`，将输入流作为自己的数据成员进行操作。

* `PipedInputStream`
    管道输入流，与管道输出流搭配使用，用于线程间的数据通信，二者使用 `connect` 方法进行连接。当管道中没有数据的时候，如果尝试从输入流中读取数据会引起线程阻塞。

* `SequenceInputStream`
    可以将两个字节输入流合并起来，读取的时候，先读取第一个输入流的数据，第一个输入流读取完毕再读取另一个输入流的数据。

* `ByteArrayInputStream`
    字节数组输入流。将已有的字节数组包装为输入流，使得可以通过处理流的方式处理输入流。
